---
title: ngx_http_mp4_module ‚ú©
description: ngx_http_mp4_module ‚ú©
toc: true
nd-org-source: http/ngx_http_mp4_module.xml
nd-plus: false
nd-partial-plus: true
---


<!--
********************************************************************************
üõë WARNING: AUTOGENERATED FILE - DO NOT EDIT üõë
This Markdown file was automatically generated from the source XML documentation.
Any manual changes made directly to this file will be overwritten.
To request or suggest changes, please edit the source XML files instead.
https://github.com/nginx/nginx.org/tree/main/xml/en
********************************************************************************
-->


The `ngx_http_mp4_module` module provides pseudo-streaming
server-side support for MP4 files.
Such files typically have the .mp4, .m4v,
or .m4a filename extensions.

Pseudo-streaming works in alliance with a compatible media player.
The player sends an HTTP request to the server with the start time
specified in the query string argument (named simply
`start`
and specified in seconds), and the server responds with the stream
such that its start position corresponds to the requested time,
for example:

```nginx
http://example.com/elephants_dream.mp4?start=238.88

```


This allows performing a random seeking at any time, or starting playback
in the middle of the timeline.

To support seeking, H.264-based formats store metadata
in a so-called ‚Äúmoov atom‚Äù.
It is a part of the file that holds the index information for the
whole file.

To start playback, the player first needs to read metadata.
This is done by sending a special request with the
`start=0` argument.
A lot of encoding software insert the metadata at
the end of the file.
This is suboptimal for pseudo-streaming, because the player
has to download the entire file before starting playback.
If the metadata are located at the beginning of the file,
it is enough for nginx to simply start sending back the file contents.
If the metadata are located at the end of the file,
nginx must read the entire file and prepare a new stream so that
the metadata come before the media data.
This involves some CPU, memory, and disk I/O overhead,
so it is a good idea to
[
prepare an original file for pseudo-streaming](https://github.com/flowplayer/flowplayer/wiki/7.1.1-video-file-correction) in advance,
rather than having nginx do this on every such request.

The module also supports the `end` argument of an HTTP request
(1.5.13) which sets the end point of playback.
The `end` argument can be specified with the
`start` argument
or separately:

```nginx
http://example.com/elephants_dream.mp4?start=238.88&end=555.55

```


For a matching request with a non-zero
`start` or `end`
argument, nginx will read the metadata from the file, prepare the
stream with the requested time range, and send it to the client.
This has the same overhead as described above.

If the `start` argument points to
a non-key video frame,
the beginning of such video will be broken.
To fix this issue, the video
[can](#mp4_start_key_frame) be prepended with
the key frame before `start` point
and with all intermediate frames between them.
These frames will be hidden from playback
using an edit list (1.21.4).

If a matching request does not include the
`start` and `end`
arguments, there is no overhead, and the file is sent simply as a static
resource.
Some players also support byte-range requests, and thus do not require
this module.

This module is not built by default, it should be enabled with the
`--with-http_mp4_module`
configuration parameter.

If a third-party mp4 module was previously used, it should be disabled.

A similar pseudo-streaming support for FLV files is provided by the
[ngx_http_flv_module](/nginx/module-reference/http/ngx_http_flv_module) module.
## Example Configuration


```nginx
location /video/ {
    mp4;
    mp4_buffer_size       1m;
    mp4_max_buffer_size   5m;
    mp4_limit_rate        on;
    mp4_limit_rate_after  30s;
}

```

## Directives

### mp4

{{< call-out >}}

**Syntax:** mp4 

**Default:** -

**Context:** location


{{</call-out>}}


Turns on module processing in a surrounding location.
### mp4_buffer_size

{{< call-out >}}

**Syntax:** mp4_buffer_size `size`

**Default:** 512K

**Context:** http, server, location


{{</call-out>}}


Sets the initial `size` of the buffer used for
processing MP4 files.
### mp4_max_buffer_size

{{< call-out >}}

**Syntax:** mp4_max_buffer_size `size`

**Default:** 10M

**Context:** http, server, location


{{</call-out>}}


During metadata processing, a larger buffer may become necessary.
Its size cannot exceed the specified `size`,
or else nginx will return the
 server error,
and log the following message:

```nginx
"/some/movie/file.mp4" mp4 moov atom is too large:
12583268, you may want to increase mp4_max_buffer_size

```

### mp4_limit_rate ‚ú©

{{< call-out >}}

**Syntax:** mp4_limit_rate `on` | `off` | `factor`

**Default:** off

**Context:** http, server, location


{{</call-out>}}


Limits the rate of response transmission to a client.
The rate is limited based on the average bitrate of the
MP4 file served.
To calculate the rate, the bitrate is multiplied by the specified
`factor`.
The special value ‚Äú`on`‚Äù corresponds to the factor of 1.1.
The special value ‚Äú`off`‚Äù disables rate limiting.
The limit is set per a request, and so if a client simultaneously opens
two connections, the overall rate will be twice as much
as the specified limit.

This directive is available as part of our
commercial subscription.
### mp4_limit_rate_after ‚ú©

{{< call-out >}}

**Syntax:** mp4_limit_rate_after `time`

**Default:** 60s

**Context:** http, server, location


{{</call-out>}}


Sets the initial amount of media data (measured in playback time)
after which the further transmission of the response to a client
will be rate limited.

This directive is available as part of our
commercial subscription.
### mp4_start_key_frame

{{< call-out >}}

**Syntax:** mp4_start_key_frame `on` | `off`

**Default:** off

**Context:** http, server, location

_This directive appeared in version 1.21.4._


{{</call-out>}}


Forces output video to always start with a key video frame.
If the `start` argument does not point to a key frame,
initial frames are hidden using an mp4 edit list.
Edit lists are supported by major players and browsers such as
Chrome, Safari, QuickTime and ffmpeg,
partially supported by Firefox.
